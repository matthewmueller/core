# mako

> A pluggable build tool built around dependency trees.

[![npm version](https://img.shields.io/npm/v/mako.svg)](https://www.npmjs.com/package/mako)
[![npm dependencies](https://img.shields.io/david/makojs/core.svg)](https://david-dm.org/makojs/core)
[![npm dev dependencies](https://img.shields.io/david/dev/makojs/core.svg)](https://david-dm.org/makojs/core#info=devDependencies)
[![build status](https://img.shields.io/travis/makojs/core.svg)](https://travis-ci.org/makojs/core)

## What is this?

At it's core, mako is a build framework. On it's own, it is merely a conductor, and relies on
plugins to configure what and how it builds. As a user, you can either assemble plugins together
yourself, or simply use a bundled collection that is tailored to your use-case.

Check out the [the wiki](http://github.com/makojs/core/wiki) for resources on getting started.

## How does it work?

The main flow for a mako **build** goes through 2 distinct phases: **analyze** and **assemble**.

The **analyze** phase reads files from some source, (typically the local filesystem) identifies
dependencies, then kicks off analyze recursively as new files are discovered. Throughout this
process, a **dependency tree** is being generated.

The **assemble** phase takes the tree generated by analyze, and prepares to write the output files
to some destination. (typcially, also the local filesystem) During this phase, the tree could be
deconstructed somewhat, such as when a tree of dependencies is combined into a single output file.

Throughout these phases, are steps called **hooks**. Plugins add handlers for the hooks relevant to
the work it is doing, and register themselves _only_ for specific file extensions.

## About plugins

Plugins are **absolutely necessary** for mako to be useful. It was important for this tool to be
flexible, so much inspiration was taken from [Metalsmith](http://metalsmith.io/).

Keep an eye on [the wiki](http://github.com/makojs/core/wiki), I'll be working on adding more
resources about plugins.

## Usage

The easiest way to get up and running with mako is to use the [CLI](https://github.com/makojs/cli).
For advanced users, the JS API is also available:

```js
var mako = require('mako');
var browser = require('mako-browser');

// create a new runner
mako()
  // add the browser plugin bundle
  .use(browser())
  // run the build for index.js (assumed to be in pwd)
  .build('./index.js')
  // returns a promise
  .then(function () {
    // done
  });
```

## API

### mako()

Returns a new `runner` instance, no need for the `new` keyword.

### runner.use(...plugins) *(chainable)*

Adds a new plugin to the runner. Each plugin is a `Function`, so any nested arrays will be
flattened, allowing you to nest freely. (particularly useful for bundles)

### runner.build(...entries)

The primary public interface, which runs both analysis and assemble for the given `entries`. It
returns a `Promise` that resolves with an object that contains some information about the build
itself.

### runner.analyze(...entries)

Runs an analysis on the passed `entries`. This method isn't typically used directly, but it can be
useful when you know what you are doing.

It returns a `Promise` that resolves with a build information object.

### runner.assemble(...entries)

Runs the assemble phase for the given `entries`, this will skip the analyze phase in case you know
it has already been finished. (such as when calling `runner.analyze()` manually)

It returns a `Promise` that resolves with a build information object.
